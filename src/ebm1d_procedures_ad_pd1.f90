!                           DISCLAIMER
! 
!   This file was generated by TAF version 4.0.3
! 
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
! 
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
! 
subroutine calculateglobalaverage( weight, value, globalaverage )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use ebm1dparameters
use ebm1dgrids
use ebm1dvariables

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: globalaverage
real, intent(in) :: value(1:jmt)
real, intent(in) :: weight(1:jmt)

!==============================================
! declare local variables
!==============================================
integer :: j
real :: sumofweights
real :: weightedsum

sumofweights = 0.0
weightedsum = 0.0
do j = 2, jmt-1
  sumofweights = sumofweights+weight(j)
  weightedsum = weightedsum+weight(j)*value(j)
end do
globalaverage = weightedsum/sumofweights
end subroutine calculateglobalaverage

subroutine core_ad()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use runparameters
use ebm1dgrids
use ebm1dvariables
use ebm1dparameters
use cost1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: dayofyear
integer :: j
real :: tape1_dayofyear_5h(2000000)
real :: tape1_ev_deltatbeg_6h(2000000)
real :: tape1_ev_deltatend_7h(2000000)
real :: tape1_ev_tsfc_3h(jmt,2000000)
real :: tape1_rp_mytime_4h(2000000)

!==============================================
! declare external procedures and functions
!==============================================
real, external :: orbtime2longitude

!----------------------------------------------
! TAPE COMPUTATIONS
!----------------------------------------------
rp_mytime = rp_starttime
ev_deltatbeg = 0.5
dayofyear = ev_deltatbeg+0.5*rp_deltat/86400.0
ev_deltatend = ev_deltatbeg+rp_deltat/86400.0
do rp_myiter = 1, rp_ntimesteps
  tape1_ev_tsfc_3h(:,rp_myiter) = ev_tsfc
  tape1_rp_mytime_4h(rp_myiter) = rp_mytime
  tape1_dayofyear_5h(rp_myiter) = dayofyear
  tape1_ev_deltatbeg_6h(rp_myiter) = ev_deltatbeg
  tape1_ev_deltatend_7h(rp_myiter) = ev_deltatend
  rp_mytime = rp_mytime+rp_deltat
  dayofyear = dayofyear+rp_deltat/86400.0
  if (dayofyear .gt. 365.5) then
    dayofyear = dayofyear-365.0
  endif
  ev_deltatbeg = ev_deltatbeg+rp_deltat/86400.0
  if (ev_deltatbeg .gt. 365.5) then
    ev_deltatbeg = ev_deltatbeg-365.0
  endif
  ev_deltatend = ev_deltatend+rp_deltat/86400.0
  if (ev_deltatend .gt. 365.5) then
    ev_deltatend = ev_deltatend-365.0
  endif
  ev_lambdap = orbtime2longitude(ep_eccen,ep_perihp,dayofyear)
  do j = 2, jmt-1
    call orbdaily( ep_scon0,ep_eccen,ep_obliq,ep_perihp,ev_lambdap,eg_yt(j),ev_solin(j),ev_cosz(j) )
  end do
  call ebm1dintegratemd
end do

!----------------------------------------------
! ADJOINT COMPUTATIONS
!----------------------------------------------
do rp_myiter = rp_ntimesteps, 1, -1
  ev_tsfc = tape1_ev_tsfc_3h(:,rp_myiter)
  rp_mytime = tape1_rp_mytime_4h(rp_myiter)
  dayofyear = tape1_dayofyear_5h(rp_myiter)
  ev_deltatbeg = tape1_ev_deltatbeg_6h(rp_myiter)
  ev_deltatend = tape1_ev_deltatend_7h(rp_myiter)
  rp_mytime = rp_mytime+rp_deltat
  dayofyear = dayofyear+rp_deltat/86400.0
  if (dayofyear .gt. 365.5) then
    dayofyear = dayofyear-365.0
  endif
  ev_deltatbeg = ev_deltatbeg+rp_deltat/86400.0
  if (ev_deltatbeg .gt. 365.5) then
    ev_deltatbeg = ev_deltatbeg-365.0
  endif
  ev_deltatend = ev_deltatend+rp_deltat/86400.0
  if (ev_deltatend .gt. 365.5) then
    ev_deltatend = ev_deltatend-365.0
  endif
  ev_lambdap = orbtime2longitude(ep_eccen,ep_perihp,dayofyear)
  do j = 2, jmt-1
    call orbdaily( ep_scon0,ep_eccen,ep_obliq,ep_perihp,ev_lambdap,eg_yt(j),ev_solin(j),ev_cosz(j) )
  end do
  call cost1daccumulatemeans_ad
  call ebm1dintegrate_ad
end do

end subroutine core_ad

subroutine core()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use runparameters
use ebm1dgrids
use ebm1dvariables
use ebm1dparameters
use cost1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: dayofyear
integer :: j

!==============================================
! declare external procedures and functions
!==============================================
real, external :: orbtime2longitude

rp_mytime = rp_starttime
ev_deltatbeg = 0.5
dayofyear = ev_deltatbeg+0.5*rp_deltat/86400.0
ev_deltatend = ev_deltatbeg+rp_deltat/86400.0
do rp_myiter = 1, rp_ntimesteps
  rp_mytime = rp_mytime+rp_deltat
  dayofyear = dayofyear+rp_deltat/86400.0
  if (dayofyear .gt. 365.5) then
    dayofyear = dayofyear-365.0
  endif
  ev_deltatbeg = ev_deltatbeg+rp_deltat/86400.0
  if (ev_deltatbeg .gt. 365.5) then
    ev_deltatbeg = ev_deltatbeg-365.0
  endif
  ev_deltatend = ev_deltatend+rp_deltat/86400.0
  if (ev_deltatend .gt. 365.5) then
    ev_deltatend = ev_deltatend-365.0
  endif
  ev_lambdap = orbtime2longitude(ep_eccen,ep_perihp,dayofyear)
  ev_lambda = ev_lambdap-90.0
  do j = 2, jmt-1
    call orbdaily( ep_scon0,ep_eccen,ep_obliq,ep_perihp,ev_lambdap,eg_yt(j),ev_solin(j),ev_cosz(j) )
  end do
  call ebm1dintegrate
  call cost1daccumulatemeans
end do
end subroutine core

subroutine cost1daccumulatemeans_ad()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dparameters
use ebm1dvariables
use cost1dparameters
use cost1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: deltatfrac
integer :: j

if (rp_mytime .gt. rp_endtime-cp_lastinterval) then
  if (cv_seasonbeg(cp_iaug) .lt. ev_deltatend .and. ev_deltatbeg .lt. cv_seasonend(cp_iaug)) then
    if (ev_deltatbeg .lt. cv_seasonbeg(cp_iaug)) then
      deltatfrac = ev_deltatend-cv_seasonbeg(cp_iaug)
    else if (cv_seasonend(cp_iaug) .lt. ev_deltatend) then
      deltatfrac = cv_seasonend(cp_iaug)-ev_deltatbeg
    else
      deltatfrac = ev_deltatend-ev_deltatbeg
    endif
    do j = 2, jmt-1
      ev_tsfc_ad(j) = ev_tsfc_ad(j)+cv_longtermmeanstgrid_ad(j,cp_iaug,cp_itsfc)*deltatfrac
      ev_apln_ad(j) = ev_apln_ad(j)+cv_longtermmeanstgrid_ad(j,cp_iaug,cp_iapln)*deltatfrac
    end do
  endif
  if (cv_seasonbeg(cp_ifeb) .lt. ev_deltatend .and. ev_deltatbeg .lt. cv_seasonend(cp_ifeb)) then
    if (ev_deltatbeg .lt. cv_seasonbeg(cp_ifeb)) then
      deltatfrac = ev_deltatend-cv_seasonbeg(cp_ifeb)
    else if (cv_seasonend(cp_ifeb) .lt. ev_deltatend) then
      deltatfrac = cv_seasonend(cp_ifeb)-ev_deltatbeg
    else
      deltatfrac = ev_deltatend-ev_deltatbeg
    endif
    do j = 2, jmt-1
      ev_tsfc_ad(j) = ev_tsfc_ad(j)+cv_longtermmeanstgrid_ad(j,cp_ifeb,cp_itsfc)*deltatfrac
      ev_apln_ad(j) = ev_apln_ad(j)+cv_longtermmeanstgrid_ad(j,cp_ifeb,cp_iapln)*deltatfrac
    end do
  endif
  do j = 2, jmt-1
    ev_tsfc_ad(j) = ev_tsfc_ad(j)+cv_longtermmeanstgrid_ad(j,cp_iann,cp_itsfc)*rp_deltat
    ev_apln_ad(j) = ev_apln_ad(j)+cv_longtermmeanstgrid_ad(j,cp_iann,cp_iapln)*rp_deltat
  end do
endif

end subroutine cost1daccumulatemeans_ad

subroutine cost1daccumulatemeans()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dparameters
use ebm1dvariables
use cost1dparameters
use cost1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: deltatfrac
integer :: j

if (rp_mytime .gt. rp_endtime-cp_lastinterval) then
  cv_longtermtimes(cp_iann) = cv_longtermtimes(cp_iann)+rp_deltat
  cv_longtermmeans(cp_iann,cp_iyice_s) = cv_longtermmeans(cp_iann,cp_iyice_s)+ev_yice_s*rp_deltat
  cv_longtermmeans(cp_iann,cp_iyice_n) = cv_longtermmeans(cp_iann,cp_iyice_n)+ev_yice_n*rp_deltat
  do j = 2, jmt-1
    cv_longtermmeanstgrid(j,cp_iann,cp_isolin) = cv_longtermmeanstgrid(j,cp_iann,cp_isolin)+ev_solin(j)*rp_deltat
    cv_longtermmeanstgrid(j,cp_iann,cp_iapln) = cv_longtermmeanstgrid(j,cp_iann,cp_iapln)+ev_apln(j)*rp_deltat
    cv_longtermmeanstgrid(j,cp_iann,cp_itsfc) = cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)+ev_tsfc(j)*rp_deltat
  end do
  do j = 2, jmt-2
    cv_longtermmeansugrid(j,cp_iann,cp_iheddy) = cv_longtermmeansugrid(j,cp_iann,cp_iheddy)+ev_heddy(j)*rp_deltat
  end do
  if (cv_seasonbeg(cp_ifeb) .lt. ev_deltatend .and. ev_deltatbeg .lt. cv_seasonend(cp_ifeb)) then
    if (ev_deltatbeg .lt. cv_seasonbeg(cp_ifeb)) then
      deltatfrac = ev_deltatend-cv_seasonbeg(cp_ifeb)
    else if (cv_seasonend(cp_ifeb) .lt. ev_deltatend) then
      deltatfrac = cv_seasonend(cp_ifeb)-ev_deltatbeg
    else
      deltatfrac = ev_deltatend-ev_deltatbeg
    endif
    cv_longtermtimes(cp_ifeb) = cv_longtermtimes(cp_ifeb)+deltatfrac
    cv_longtermmeans(cp_ifeb,cp_iyice_s) = cv_longtermmeans(cp_ifeb,cp_iyice_s)+ev_yice_s*deltatfrac
    cv_longtermmeans(cp_ifeb,cp_iyice_n) = cv_longtermmeans(cp_ifeb,cp_iyice_n)+ev_yice_n*deltatfrac
    do j = 2, jmt-1
      cv_longtermmeanstgrid(j,cp_ifeb,cp_isolin) = cv_longtermmeanstgrid(j,cp_ifeb,cp_isolin)+ev_solin(j)*deltatfrac
      cv_longtermmeanstgrid(j,cp_ifeb,cp_iapln) = cv_longtermmeanstgrid(j,cp_ifeb,cp_iapln)+ev_apln(j)*deltatfrac
      cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc) = cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc)+ev_tsfc(j)*deltatfrac
    end do
    do j = 2, jmt-2
      cv_longtermmeansugrid(j,cp_ifeb,cp_iheddy) = cv_longtermmeansugrid(j,cp_ifeb,cp_iheddy)+ev_heddy(j)*deltatfrac
    end do
  endif
  if (cv_seasonbeg(cp_iaug) .lt. ev_deltatend .and. ev_deltatbeg .lt. cv_seasonend(cp_iaug)) then
    if (ev_deltatbeg .lt. cv_seasonbeg(cp_iaug)) then
      deltatfrac = ev_deltatend-cv_seasonbeg(cp_iaug)
    else if (cv_seasonend(cp_iaug) .lt. ev_deltatend) then
      deltatfrac = cv_seasonend(cp_iaug)-ev_deltatbeg
    else
      deltatfrac = ev_deltatend-ev_deltatbeg
    endif
    cv_longtermtimes(cp_iaug) = cv_longtermtimes(cp_iaug)+deltatfrac
    cv_longtermmeans(cp_iaug,cp_iyice_s) = cv_longtermmeans(cp_iaug,cp_iyice_s)+ev_yice_s*deltatfrac
    cv_longtermmeans(cp_iaug,cp_iyice_n) = cv_longtermmeans(cp_iaug,cp_iyice_n)+ev_yice_n*deltatfrac
    do j = 2, jmt-1
      cv_longtermmeanstgrid(j,cp_iaug,cp_isolin) = cv_longtermmeanstgrid(j,cp_iaug,cp_isolin)+ev_solin(j)*deltatfrac
      cv_longtermmeanstgrid(j,cp_iaug,cp_iapln) = cv_longtermmeanstgrid(j,cp_iaug,cp_iapln)+ev_apln(j)*deltatfrac
      cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc) = cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc)+ev_tsfc(j)*deltatfrac
    end do
    do j = 2, jmt-2
      cv_longtermmeansugrid(j,cp_iaug,cp_iheddy) = cv_longtermmeansugrid(j,cp_iaug,cp_iheddy)+ev_heddy(j)*deltatfrac
    end do
  endif
endif
end subroutine cost1daccumulatemeans

subroutine cost1dinitializevariables()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use cost1dvariables

implicit none

cv_longtermtimes = 0.0
cv_longtermmeans = 0.0
cv_longtermmeanstgrid = 0.0
cv_longtermmeansugrid = 0.0
end subroutine cost1dinitializevariables

subroutine cost1dreadparameters()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use cost1dparameters

implicit none

cp_lastinterval = 10.0*c_days_per_year*c_seconds_per_day
cp_longitudebeg(cp_ifeb) = -48.780691
cp_longitudeend(cp_ifeb) = -20.483465
cp_longitudebeg(cp_iaug) = 127.968121
cp_longitudeend(cp_iaug) = 157.795565
end subroutine cost1dreadparameters

subroutine ebm1dcalculateicealbedo_ad( yt, yu, tcrit, asfc, aice, t, t_ad, apln_ad, yice_s_ad, yice_n_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use runparameters, only : rp_myiter

implicit none

!==============================================
! declare common blocks
!==============================================
integer :: tape1_jice_n_2h(2000000)
common /jice_nc_ad/ tape1_jice_n_2h

integer :: tape1_jice_s_1h(2000000)
common /jice_sc_ad/ tape1_jice_s_1h

!==============================================
! declare arguments
!==============================================
real, intent(in) :: aice
real, intent(inout) :: apln_ad(1:jmt)
real, intent(in) :: asfc(1:jmt)
real, intent(in) :: t(1:jmt)
real, intent(inout) :: t_ad(1:jmt)
real, intent(in) :: tcrit
real, intent(inout) :: yice_n_ad
real, intent(inout) :: yice_s_ad
real, intent(in) :: yt(1:jmt)
real, intent(in) :: yu(1:jmt)

!==============================================
! declare local variables
!==============================================
real :: amix_n_ad
real :: amix_s_ad
real :: dphi
real :: dphi_ad
integer :: ikey
integer :: j
integer :: jice_n
integer :: jice_s
integer :: jmtm1
real :: wice_ad
real :: yice_n
real :: yice_s
real :: ynorth
real :: ysouth

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES NO ALLOC
!----------------------------------------------
amix_n_ad = 0.
amix_s_ad = 0.
dphi_ad = 0.
wice_ad = 0.

jmtm1 = jmt-1
jice_s = -1
do j = 2, jmt/2
  if (jice_s .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j+1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j+1))/(t(j+1)-t(j))*0.1745/c_deg2rad
      yice_s = yt(j+1)-dphi
      if (yice_s .gt. yu(j)) then
        jice_s = j+1
      else
        jice_s = j
      endif
    endif
  endif
end do
jice_n = -1
do j = jmtm1, jmt/2+1, -1
  if (jice_n .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j-1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j-1))/(t(j-1)-t(j))*0.1745/c_deg2rad
      yice_n = yt(j-1)+dphi
      if (yice_n .lt. yu(j-1)) then
        jice_n = j-1
      else
        jice_n = j
      endif
    endif
  endif
end do
if (t(jmtm1) .gt. tcrit) then
  do j = jmtm1, jmt/2+1, -1
    apln_ad(j) = 0.
  end do
else if (t(jmt/2+1) .le. tcrit) then
  do j = jmtm1, jmt/2+1, -1
    apln_ad(j) = 0.
  end do
else
  do j = jice_n-1, jmt/2+1, -1
    apln_ad(j) = 0.
  end do
  amix_n_ad = amix_n_ad+apln_ad(jice_n)
  apln_ad(jice_n) = 0.
  do j = jmtm1, jice_n+1, -1
    apln_ad(j) = 0.
  end do
endif
do j = jmt/2+1, jmtm1
  ikey = (rp_myiter-1)*jmt+j
  jice_n = tape1_jice_n_2h(ikey)
  if (jice_n .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j-1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j-1))/(t(j-1)-t(j))*0.1745/c_deg2rad
      yice_n = yt(j-1)+dphi
      if (yice_n .lt. yu(j-1)) then
        ysouth = yu(j-2)
        ynorth = yu(j-1)
        wice_ad = wice_ad+amix_n_ad*((-asfc(j-1))+aice)
        amix_n_ad = 0.
        yice_n_ad = yice_n_ad-wice_ad*(cos(yice_n*c_deg2rad)/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad)))*c_deg2rad
        wice_ad = 0.
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice_ad = wice_ad+amix_n_ad*((-asfc(j))+aice)
        amix_n_ad = 0.
        yice_n_ad = yice_n_ad-wice_ad*(cos(yice_n*c_deg2rad)/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad)))*c_deg2rad
        wice_ad = 0.
      endif
      dphi_ad = dphi_ad+yice_n_ad
      yice_n_ad = 0.
      t_ad(j-1) = t_ad(j-1)+dphi_ad*(0.1745*((1-((-tcrit)+t(j-1))/(t(j-1)-t(j)))/(t(j-1)-t(j)))/c_deg2rad)
      t_ad(j) = t_ad(j)+dphi_ad*(0.1745*(((-tcrit)+t(j-1))/(t(j-1)-t(j))/(t(j-1)-t(j)))/c_deg2rad)
      dphi_ad = 0.
    endif
  endif
end do
if (t(2) .gt. tcrit) then
  do j = 2, jmt/2
    apln_ad(j) = 0.
  end do
else if (t(jmt/2) .le. tcrit) then
  do j = 2, jmt/2
    apln_ad(j) = 0.
  end do
else
  do j = jice_s+1, jmt/2
    apln_ad(j) = 0.
  end do
  amix_s_ad = amix_s_ad+apln_ad(jice_s)
  apln_ad(jice_s) = 0.
  do j = 2, jice_s-1
    apln_ad(j) = 0.
  end do
endif
do j = jmt/2, 2, -1
  ikey = (rp_myiter-1)*jmt+j
  jice_s = tape1_jice_s_1h(ikey)
  if (jice_s .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j+1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j+1))/(t(j+1)-t(j))*0.1745/c_deg2rad
      yice_s = yt(j+1)-dphi
      if (yice_s .gt. yu(j)) then
        ysouth = yu(j)
        ynorth = yu(j+1)
        wice_ad = wice_ad+amix_s_ad*((-asfc(j+1))+aice)
        amix_s_ad = 0.
        yice_s_ad = yice_s_ad+wice_ad*(cos(yice_s*c_deg2rad)/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad)))*c_deg2rad
        wice_ad = 0.
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice_ad = wice_ad+amix_s_ad*((-asfc(j))+aice)
        amix_s_ad = 0.
        yice_s_ad = yice_s_ad+wice_ad*(cos(yice_s*c_deg2rad)/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad)))*c_deg2rad
        wice_ad = 0.
      endif
      dphi_ad = dphi_ad-yice_s_ad
      yice_s_ad = 0.
      t_ad(j+1) = t_ad(j+1)+dphi_ad*(0.1745*((1-((-tcrit)+t(j+1))/(t(j+1)-t(j)))/(t(j+1)-t(j)))/c_deg2rad)
      t_ad(j) = t_ad(j)+dphi_ad*(0.1745*(((-tcrit)+t(j+1))/(t(j+1)-t(j))/(t(j+1)-t(j)))/c_deg2rad)
      dphi_ad = 0.
    endif
  endif
end do

end subroutine ebm1dcalculateicealbedo_ad

subroutine ebm1dcalculateicealbedomd( dyt, dyu, yt, yu, tcrit, asfc, aice, t, apln, jice_s, jice_n, yice_s, yice_n )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use runparameters, only : rp_myiter

implicit none

!==============================================
! declare common blocks
!==============================================
integer :: tape1_jice_n_2h(2000000)
common /jice_nc_ad/ tape1_jice_n_2h

integer :: tape1_jice_s_1h(2000000)
common /jice_sc_ad/ tape1_jice_s_1h

!==============================================
! declare arguments
!==============================================
real, intent(in) :: aice
real, intent(inout) :: apln(1:jmt)
real, intent(in) :: asfc(1:jmt)
real, intent(in) :: dyt(1:jmt)
real, intent(in) :: dyu(1:jmt)
integer, intent(inout) :: jice_n
integer, intent(inout) :: jice_s
real, intent(in) :: t(1:jmt)
real, intent(in) :: tcrit
real, intent(inout) :: yice_n
real, intent(inout) :: yice_s
real, intent(in) :: yt(1:jmt)
real, intent(in) :: yu(1:jmt)

!==============================================
! declare local variables
!==============================================
real :: amix_n
real :: amix_s
real :: dphi
integer :: ikey
integer :: j
integer :: jmtm1
real :: wice
real :: ynorth
real :: ysouth

!**********************************************
! executable statements of routine
!**********************************************
jmtm1 = jmt-1
jice_s = -1
do j = 2, jmt/2
  ikey = (rp_myiter-1)*jmt+j
  tape1_jice_s_1h(ikey) = jice_s
  if (jice_s .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j+1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j+1))/(t(j+1)-t(j))*0.1745/c_deg2rad
      yice_s = yt(j+1)-dphi
      if (yice_s .gt. yu(j)) then
        ysouth = yu(j)
        ynorth = yu(j+1)
        wice = (sin(yice_s*c_deg2rad)-sin(ysouth*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_s = asfc(j+1)*(1.0-wice)+aice*wice
        jice_s = j+1
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice = (sin(yice_s*c_deg2rad)-sin(ysouth*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_s = asfc(j)*(1.0-wice)+aice*wice
        jice_s = j
      endif
    endif
  endif
end do
if (t(2) .gt. tcrit) then
  jice_s = 0
  yice_s = -90.0
  do j = 2, jmt/2
    apln(j) = asfc(j)
  end do
else if (t(jmt/2) .le. tcrit) then
  jice_s = jmt/2
  yice_s = 0.0
  do j = 2, jmt/2
    apln(j) = aice
  end do
else
  do j = 2, jice_s-1
    apln(j) = aice
  end do
  apln(jice_s) = amix_s
  do j = jice_s+1, jmt/2
    apln(j) = asfc(j)
  end do
endif
jice_n = -1
do j = jmtm1, jmt/2+1, -1
  ikey = (rp_myiter-1)*jmt+j
  tape1_jice_n_2h(ikey) = jice_n
  if (jice_n .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j-1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j-1))/(t(j-1)-t(j))*0.1745/c_deg2rad
      yice_n = yt(j-1)+dphi
      if (yice_n .lt. yu(j-1)) then
        ysouth = yu(j-2)
        ynorth = yu(j-1)
        wice = (sin(ynorth*c_deg2rad)-sin(yice_n*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_n = asfc(j-1)*(1.0-wice)+aice*wice
        jice_n = j-1
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice = (sin(ynorth*c_deg2rad)-sin(yice_n*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_n = asfc(j)*(1.0-wice)+aice*wice
        jice_n = j
      endif
    endif
  endif
end do
if (t(jmtm1) .gt. tcrit) then
  jice_n = 0
  yice_n = 90.0
  do j = jmtm1, jmt/2+1, -1
    apln(j) = asfc(j)
  end do
else if (t(jmt/2+1) .le. tcrit) then
  jice_n = jmt/2
  yice_n = 0.0
  do j = jmtm1, jmt/2+1, -1
    apln(j) = aice
  end do
else
  do j = jmtm1, jice_n+1, -1
    apln(j) = aice
  end do
  apln(jice_n) = amix_n
  do j = jice_n-1, jmt/2+1, -1
    apln(j) = asfc(j)
  end do
endif
end subroutine ebm1dcalculateicealbedomd

subroutine ebm1dcalculateicealbedo( dyt, dyu, yt, yu, tcrit, asfc, aice, t, apln, jice_s, jice_n, yice_s, yice_n )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use runparameters, only : rp_myiter

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: aice
real, intent(inout) :: apln(1:jmt)
real, intent(in) :: asfc(1:jmt)
real, intent(in) :: dyt(1:jmt)
real, intent(in) :: dyu(1:jmt)
integer, intent(inout) :: jice_n
integer, intent(inout) :: jice_s
real, intent(in) :: t(1:jmt)
real, intent(in) :: tcrit
real, intent(inout) :: yice_n
real, intent(inout) :: yice_s
real, intent(in) :: yt(1:jmt)
real, intent(in) :: yu(1:jmt)

!==============================================
! declare local variables
!==============================================
real :: amix_n
real :: amix_s
real :: dphi
integer :: ikey
integer :: j
integer :: jmtm1
real :: wice
real :: ynorth
real :: ysouth

jmtm1 = jmt-1
jice_s = -1
do j = 2, jmt/2
  ikey = (rp_myiter-1)*jmt+j
  if (jice_s .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j+1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j+1))/(t(j+1)-t(j))*0.1745/c_deg2rad
      yice_s = yt(j+1)-dphi
      if (yice_s .gt. yu(j)) then
        ysouth = yu(j)
        ynorth = yu(j+1)
        wice = (sin(yice_s*c_deg2rad)-sin(ysouth*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_s = asfc(j+1)*(1.0-wice)+aice*wice
        jice_s = j+1
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice = (sin(yice_s*c_deg2rad)-sin(ysouth*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_s = asfc(j)*(1.0-wice)+aice*wice
        jice_s = j
      endif
    endif
  endif
end do
if (t(2) .gt. tcrit) then
  jice_s = 0
  yice_s = -90.0
  do j = 2, jmt/2
    apln(j) = asfc(j)
  end do
else if (t(jmt/2) .le. tcrit) then
  jice_s = jmt/2
  yice_s = 0.0
  do j = 2, jmt/2
    apln(j) = aice
  end do
else
  do j = 2, jice_s-1
    apln(j) = aice
  end do
  apln(jice_s) = amix_s
  do j = jice_s+1, jmt/2
    apln(j) = asfc(j)
  end do
endif
jice_n = -1
do j = jmtm1, jmt/2+1, -1
  ikey = (rp_myiter-1)*jmt+j
  if (jice_n .lt. 0) then
    if (t(j) .lt. tcrit .and. t(j-1) .ge. tcrit) then
      dphi = ((-tcrit)+t(j-1))/(t(j-1)-t(j))*0.1745/c_deg2rad
      yice_n = yt(j-1)+dphi
      if (yice_n .lt. yu(j-1)) then
        ysouth = yu(j-2)
        ynorth = yu(j-1)
        wice = (sin(ynorth*c_deg2rad)-sin(yice_n*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_n = asfc(j-1)*(1.0-wice)+aice*wice
        jice_n = j-1
      else
        ysouth = yu(j-1)
        ynorth = yu(j)
        wice = (sin(ynorth*c_deg2rad)-sin(yice_n*c_deg2rad))/(sin(ynorth*c_deg2rad)-sin(ysouth*c_deg2rad))
        amix_n = asfc(j)*(1.0-wice)+aice*wice
        jice_n = j
      endif
    endif
  endif
end do
if (t(jmtm1) .gt. tcrit) then
  jice_n = 0
  yice_n = 90.0
  do j = jmtm1, jmt/2+1, -1
    apln(j) = asfc(j)
  end do
else if (t(jmt/2+1) .le. tcrit) then
  jice_n = jmt/2
  yice_n = 0.0
  do j = jmtm1, jmt/2+1, -1
    apln(j) = aice
  end do
else
  do j = jmtm1, jice_n+1, -1
    apln(j) = aice
  end do
  apln(jice_n) = amix_n
  do j = jice_n-1, jmt/2+1, -1
    apln(j) = asfc(j)
  end do
endif
end subroutine ebm1dcalculateicealbedo

subroutine ebm1dinitializefixed()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use ebm1dparameters
use ebm1dgrids

implicit none

!==============================================
! declare local variables
!==============================================
integer :: nfields

nfields = 1
call orbinitializeelements
call orbcomputeelements( ep_pyear,ep_eccen,ep_perih,ep_obliq,ep_clipr )
ep_perihp = ep_perih-90.0
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'pyear   = ',ep_pyear
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'eccen   = ',ep_eccen
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'perih   = ',ep_perih
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'obliq   = ',ep_obliq
9000 format(1x,10a)
end subroutine ebm1dinitializefixed

subroutine ebm1dinitializegrids()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dparameters
use ebm1dgrids

implicit none

!==============================================
! declare local variables
!==============================================
real :: cst(1:jmt)
real :: csu(1:jmt)
real :: dxt
real :: dxtdeg
real :: dxu
real :: dxudeg
real :: dyt(1:jmt)
real :: dytdeg(1:jmt)
real :: dyu(1:jmt)
real :: dyudeg(1:jmt)
integer :: errio
integer :: j
integer :: jmd
real :: sint(1:jmt)
real :: sinu(1:jmt)
real :: yt(1:jmt)
real :: yu(1:jmt)

write(unit=c_standard_message_unit,fmt=9000) 'Ebm1D grids are read from file "',trim(ep_gridfilename),'"'
open(unit=c_model_data_unit,file=ep_gridfilename,status='OLD',iostat=errio)
read(unit=c_model_data_unit,fmt=*) jmd
read(unit=c_model_data_unit,fmt=*) dxtdeg
read(unit=c_model_data_unit,fmt=*) dxudeg
read(unit=c_model_data_unit,fmt=*) dytdeg(1:jmt)
read(unit=c_model_data_unit,fmt=*) dyudeg(1:jmt)
read(unit=c_model_data_unit,fmt=*) yt(1:jmt)
read(unit=c_model_data_unit,fmt=*) yu(1:jmt)
close(unit=c_model_data_unit)
dxt = dxtdeg*c_deg2dist
dxu = dxudeg*c_deg2dist
do j = 1, jmt
  dyt(j) = dytdeg(j)*c_deg2dist
  dyu(j) = dyudeg(j)*c_deg2dist
end do
do j = 1, jmt
  cst(j) = cos(yt(j)*c_deg2rad)
  csu(j) = cos(yu(j)*c_deg2rad)
  sint(j) = sin(yt(j)*c_deg2rad)
  sinu(j) = sin(yu(j)*c_deg2rad)
end do
eg_jmt = jmt
eg_dxt = dxt
eg_dxu = dxu
eg_dyt = dyt
eg_dyu = dyu
eg_yt = yt
eg_yu = yu
eg_cst = cst
eg_csu = csu
eg_sint = sint
eg_sinu = sinu
9000 format(1x,10a)
end subroutine ebm1dinitializegrids

subroutine ebm1dinitializevariables()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use ebm1dparameters
use ebm1dgrids
use ebm1dvariables
use initialconditions

implicit none

ev_tsfc = ic_tsfc
ev_netswpln = 0.0
ev_netlwpln = 0.0
ev_heddy = 0.0
ev_div_heddy = 0.0
ev_solin = 0.0
ev_apln = 0.0
ev_diff_cnt = 0.0
end subroutine ebm1dinitializevariables

subroutine ebm1dintegrate_ad()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: dareat
real :: dqco2
real :: dqco2_ad
real :: ev_yice_nh_ad
real :: ev_yice_sh_ad
real :: grad_tsfc
real :: grad_tsfc_ad
integer :: j
real :: pl1
real :: pl2
real :: source(1:jmt)
real :: source_ad(1:jmt)
real :: yp_ad(1:jmt)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES NO ALLOC
!----------------------------------------------
dqco2_ad = 0.
ev_yice_nh_ad = 0.
ev_yice_sh_ad = 0.
grad_tsfc_ad = 0.
source_ad(:) = 0.
yp_ad(:) = 0.

!$taf INCOMPLETE ev_apln,ev_apln_icefree,ev_diff_cnt,ev_div_heddy,ev_heddy,ev_netlwpln,ev_netswpln,source
do j = 2, jmt-2
  grad_tsfc = (ev_tsfc(j+1)-ev_tsfc(j))/eg_dyu(j)
  ev_diff_cnt(j) = ep_diff0*(1.0+ep_diff2*eg_sinu(j)**2+ep_diff4*eg_sinu(j)**4)
  ev_heddy(j) = eg_dxu*eg_csu(j)*ev_ceff*(-(ev_diff_cnt(j)*grad_tsfc))
end do
do j = 2, jmt-1
  dareat = eg_dxt*eg_cst(j)*eg_dyt(j)
  ev_div_heddy(j) = (ev_heddy(j)-ev_heddy(j-1))/dareat
end do
do j = 2, jmt-1
  pl1 = eg_sint(j)
  pl2 = 0.5*(3.0*eg_sint(j)**2-1.0)
  ev_apln_icefree(j) = 1.0-(ep_apln0+ep_apln1*pl1+ep_apln2*pl2)
end do
if (ep_useicealbedofeedback) then
  call ebm1dcalculateicealbedo( eg_dyt,eg_dyu,eg_yt,eg_yu,ep_tcrit,ev_apln_icefree,ep_aice,ev_tsfc,ev_apln,ev_jice_s,ev_jice_n,&
&ev_yice_s,ev_yice_n )
else
  ev_apln(2:jmt-1) = ev_apln_icefree(2:jmt-1)
endif
do j = 2, jmt-1
  ev_netswpln(j) = ev_solin(j)*(1.0-ev_apln(j))
  dqco2 = -(ep_dqco2x2*log(ep_co2ccn/ep_co2ref)/log(2.0))
  ev_netlwpln(j) = ep_alw+ep_blw*ev_tsfc(j)+dqco2
  source(j) = ev_netswpln(j)-ev_netlwpln(j)
end do
do j = 2, jmt-1
  yp_ad(j) = yp_ad(j)+ev_tsfc_ad(j)*rp_deltat
end do
do j = 2, jmt-1
  ev_ceff_ad = ev_ceff_ad-yp_ad(j)*((source(j)-ev_div_heddy(j))/ev_ceff/ev_ceff)
  ev_div_heddy_ad(j) = ev_div_heddy_ad(j)-yp_ad(j)/ev_ceff
  source_ad(j) = source_ad(j)+yp_ad(j)/ev_ceff
  yp_ad(j) = 0.
end do
do j = 2, jmt-1
  dqco2_ad = 0.
  ev_netlwpln_ad(j) = ev_netlwpln_ad(j)-source_ad(j)
  ev_netswpln_ad(j) = ev_netswpln_ad(j)+source_ad(j)
  source_ad(j) = 0.
  dqco2_ad = dqco2_ad+ev_netlwpln_ad(j)
  ep_alw_ad = ep_alw_ad+ev_netlwpln_ad(j)
  ep_blw_ad = ep_blw_ad+ev_netlwpln_ad(j)*ev_tsfc(j)
  ev_tsfc_ad(j) = ev_tsfc_ad(j)+ev_netlwpln_ad(j)*ep_blw
  ev_netlwpln_ad(j) = 0.
  ep_dqco2x2_ad = ep_dqco2x2_ad-dqco2_ad*(log(ep_co2ccn/ep_co2ref)/log(2.0))
  dqco2_ad = 0.
  ev_apln_ad(j) = ev_apln_ad(j)-ev_netswpln_ad(j)*ev_solin(j)
  ev_netswpln_ad(j) = 0.
end do
if (ep_useicealbedofeedback) then
  call ebm1dcalculateicealbedo_ad( eg_yt,eg_yu,ep_tcrit,ev_apln_icefree,ep_aice,ev_tsfc,ev_tsfc_ad,ev_apln_ad,ev_yice_sh_ad,&
&ev_yice_nh_ad )
else
  ev_apln_ad(2:jmt-1) = 0.
endif
do j = 2, jmt-1
  dareat = eg_dxt*eg_cst(j)*eg_dyt(j)
  ev_heddy_ad(j-1) = ev_heddy_ad(j-1)-ev_div_heddy_ad(j)/dareat
  ev_heddy_ad(j) = ev_heddy_ad(j)+ev_div_heddy_ad(j)/dareat
  ev_div_heddy_ad(j) = 0.
end do
do j = 2, jmt-2
  grad_tsfc_ad = 0.
!$taf INCOMPLETE ev_diff_cnt
  grad_tsfc = (ev_tsfc(j+1)-ev_tsfc(j))/eg_dyu(j)
  ev_diff_cnt(j) = ep_diff0*(1.0+ep_diff2*eg_sinu(j)**2+ep_diff4*eg_sinu(j)**4)
  ev_ceff_ad = ev_ceff_ad-ev_heddy_ad(j)*eg_dxu*eg_csu(j)*ev_diff_cnt(j)*grad_tsfc
  ev_diff_cnt_ad(j) = ev_diff_cnt_ad(j)-ev_heddy_ad(j)*eg_dxu*eg_csu(j)*ev_ceff*grad_tsfc
  grad_tsfc_ad = grad_tsfc_ad-ev_heddy_ad(j)*eg_dxu*eg_csu(j)*ev_ceff*ev_diff_cnt(j)
  ev_heddy_ad(j) = 0.
  ep_diff0_ad = ep_diff0_ad+ev_diff_cnt_ad(j)*(1.0+ep_diff2*eg_sinu(j)**2+ep_diff4*eg_sinu(j)**4)
  ep_diff2_ad = ep_diff2_ad+ev_diff_cnt_ad(j)*ep_diff0*eg_sinu(j)**2
  ep_diff4_ad = ep_diff4_ad+ev_diff_cnt_ad(j)*ep_diff0*eg_sinu(j)**4
  ev_diff_cnt_ad(j) = 0.
  ev_tsfc_ad(j+1) = ev_tsfc_ad(j+1)+grad_tsfc_ad/eg_dyu(j)
  ev_tsfc_ad(j) = ev_tsfc_ad(j)-grad_tsfc_ad/eg_dyu(j)
  grad_tsfc_ad = 0.
end do

end subroutine ebm1dintegrate_ad

subroutine ebm1dintegratemd()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: dareat
real :: dqco2
real :: grad_tsfc
integer :: j
real :: pl1
real :: pl2
real :: source(1:jmt)
real :: yp(1:jmt)

!**********************************************
! executable statements of routine
!**********************************************
do j = 2, jmt-2
  grad_tsfc = (ev_tsfc(j+1)-ev_tsfc(j))/eg_dyu(j)
  ev_diff_cnt(j) = ep_diff0*(1.0+ep_diff2*eg_sinu(j)**2+ep_diff4*eg_sinu(j)**4)
  ev_heddy(j) = eg_dxu*eg_csu(j)*ev_ceff*(-(ev_diff_cnt(j)*grad_tsfc))
end do
do j = 2, jmt-1
  dareat = eg_dxt*eg_cst(j)*eg_dyt(j)
  ev_div_heddy(j) = (ev_heddy(j)-ev_heddy(j-1))/dareat
end do
do j = 2, jmt-1
  pl1 = eg_sint(j)
  pl2 = 0.5*(3.0*eg_sint(j)**2-1.0)
  ev_apln_icefree(j) = 1.0-(ep_apln0+ep_apln1*pl1+ep_apln2*pl2)
end do
if (ep_useicealbedofeedback) then
  call ebm1dcalculateicealbedomd( eg_dyt,eg_dyu,eg_yt,eg_yu,ep_tcrit,ev_apln_icefree,ep_aice,ev_tsfc,ev_apln,ev_jice_s,ev_jice_n,&
&ev_yice_s,ev_yice_n )
else
  ev_apln(2:jmt-1) = ev_apln_icefree(2:jmt-1)
endif
do j = 2, jmt-1
  ev_netswpln(j) = ev_solin(j)*(1.0-ev_apln(j))
  dqco2 = -(ep_dqco2x2*log(ep_co2ccn/ep_co2ref)/log(2.0))
  ev_netlwpln(j) = ep_alw+ep_blw*ev_tsfc(j)+dqco2
  source(j) = ev_netswpln(j)-ev_netlwpln(j)
end do
do j = 2, jmt-1
  yp(j) = (source(j)-ev_div_heddy(j))/ev_ceff
end do
do j = 2, jmt-1
  ev_tsfc(j) = ev_tsfc(j)+rp_deltat*yp(j)
end do
end subroutine ebm1dintegratemd

subroutine ebm1dintegrate()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
real :: dareat
real :: dqco2
real :: grad_tsfc
integer :: j
real :: pl1
real :: pl2
real :: source(1:jmt)
real :: yp(1:jmt)

do j = 2, jmt-2
  grad_tsfc = (ev_tsfc(j+1)-ev_tsfc(j))/eg_dyu(j)
  ev_diff_cnt(j) = ep_diff0*(1.0+ep_diff2*eg_sinu(j)**2+ep_diff4*eg_sinu(j)**4)
  ev_heddy(j) = eg_dxu*eg_csu(j)*ev_ceff*(-(ev_diff_cnt(j)*grad_tsfc))
end do
do j = 2, jmt-1
  dareat = eg_dxt*eg_cst(j)*eg_dyt(j)
  ev_div_heddy(j) = (ev_heddy(j)-ev_heddy(j-1))/dareat
end do
do j = 2, jmt-1
  pl1 = eg_sint(j)
  pl2 = 0.5*(3.0*eg_sint(j)**2-1.0)
  ev_apln_icefree(j) = 1.0-(ep_apln0+ep_apln1*pl1+ep_apln2*pl2)
end do
if (ep_useicealbedofeedback) then
  call ebm1dcalculateicealbedo( eg_dyt,eg_dyu,eg_yt,eg_yu,ep_tcrit,ev_apln_icefree,ep_aice,ev_tsfc,ev_apln,ev_jice_s,ev_jice_n,&
&ev_yice_s,ev_yice_n )
else
  ev_apln(2:jmt-1) = ev_apln_icefree(2:jmt-1)
endif
do j = 2, jmt-1
  ev_netswpln(j) = ev_solin(j)*(1.0-ev_apln(j))
  dqco2 = -(ep_dqco2x2*log(ep_co2ccn/ep_co2ref)/log(2.0))
  ev_netlwpln(j) = ep_alw+ep_blw*ev_tsfc(j)+dqco2
  source(j) = ev_netswpln(j)-ev_netlwpln(j)
end do
do j = 2, jmt-1
  yp(j) = (source(j)-ev_div_heddy(j))/ev_ceff
end do
do j = 2, jmt-1
  ev_tsfc(j) = ev_tsfc(j)+rp_deltat*yp(j)
end do
end subroutine ebm1dintegrate

subroutine ebm1doutput()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use runparameters
use ebm1dparameters
use ebm1dgrids
use ebm1dvariables
use cost1dparameters
use cost1dvariables

implicit none

!==============================================
! declare local variables
!==============================================
integer :: errio
real :: globalaverage
integer :: j
character(len=c_max_len_filename) :: outputfilename

write(unit=c_standard_message_unit,fmt=9000) 'Restart data is written to file "',trim(rp_restartdatafilename),'".'
open(unit=c_model_data_unit,file=rp_restartdatafilename,status='REPLACE',iostat=errio)
write(unit=c_model_data_unit,fmt=9200)
do j = 2, jmt-1
  write(unit=c_model_data_unit,fmt=9100) eg_yt(j),ev_tsfc(j)
end do
close(unit=c_model_data_unit)
outputfilename = 'energy_transport_1d.dat'
write(unit=c_standard_message_unit,fmt=9000) 'Output on U grid is written to file "',trim(outputfilename),'".'
open(unit=c_model_data_unit,file=outputfilename,status='REPLACE',iostat=errio)
write(unit=c_model_data_unit,fmt=9300)
do j = 1, jmt-1
  write(unit=c_model_data_unit,fmt=9100) eg_yu(j),ev_diff_cnt(j),ev_heddy(j),cv_longtermmeansugrid(j,cp_ifeb,cp_iheddy),&
&cv_longtermmeansugrid(j,cp_iaug,cp_iheddy),cv_longtermmeansugrid(j,cp_iann,cp_iheddy)
end do
close(unit=c_model_data_unit)
outputfilename = 'energy_balance_1d.dat'
write(unit=c_standard_message_unit,fmt=9000) 'Output on T grid is written to file "',trim(outputfilename),'".'
open(unit=c_model_data_unit,file=outputfilename,status='REPLACE',iostat=errio)
write(unit=c_model_data_unit,fmt=9400)
do j = 2, jmt-1
  write(unit=c_model_data_unit,fmt=9100) eg_yt(j),ev_solin(j),ev_apln(j),ev_netswpln(j),ev_netlwpln(j),ev_div_heddy(j),ev_tsfc(j),&
&cv_longtermmeanstgrid(j,cp_ifeb,cp_isolin),cv_longtermmeanstgrid(j,cp_iaug,cp_isolin),cv_longtermmeanstgrid(j,cp_iann,cp_isolin)&
&,cv_longtermmeanstgrid(j,cp_ifeb,cp_iapln),cv_longtermmeanstgrid(j,cp_iaug,cp_iapln),cv_longtermmeanstgrid(j,cp_iann,cp_iapln),&
&cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc),cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc),cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)
end do
close(unit=c_model_data_unit)
outputfilename = 'reference.dat'
write(unit=c_standard_message_unit,fmt=9000) 'Output on T grid is written to file "',trim(outputfilename),'".'
open(unit=c_model_data_unit,file=outputfilename,status='REPLACE',iostat=errio)
write(unit=c_model_data_unit,fmt=9500)
do j = 2, jmt-1
  write(unit=c_model_data_unit,fmt=9150) eg_yt(j),cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc),cv_longtermmeanstgrid(j,cp_iaug,&
&cp_itsfc),cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)
end do
close(unit=c_model_data_unit)
call ebm1dwriteparameters
write(unit=c_standard_message_unit,fmt=*)
write(unit=c_standard_message_unit,fmt='(a)') ' *** Some long-term mean values ***'
call calculateglobalaverage( eg_cst,cv_longtermmeanstgrid(1:jmt,cp_iann,cp_iapln),globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean planetary albedo (annual)      : ',globalaverage
call calculateglobalaverage( eg_cst,cv_longtermmeanstgrid(1:jmt,cp_iann,cp_itsfc),globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean surface temperature (annual)   : ',globalaverage
call calculateglobalaverage( eg_cst,cv_longtermmeanstgrid(1:jmt,cp_ifeb,cp_itsfc),globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean surface temperature (February) : ',globalaverage
call calculateglobalaverage( eg_cst,cv_longtermmeanstgrid(1:jmt,cp_iaug,cp_itsfc),globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean surface temperature (August)   : ',globalaverage
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Annual-mean ice boundary in the southern hemisphere: lat = ',&
&cv_longtermmeans(cp_iann,cp_iyice_s)
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Annual-mean ice boundary in the northern hemisphere: lat = ',&
&cv_longtermmeans(cp_iann,cp_iyice_n)
write(unit=c_standard_message_unit,fmt=*)
write(unit=c_standard_message_unit,fmt='(a)') ' *** Some instantaneous values ***'
call calculateglobalaverage( eg_cst,ev_apln,globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean planetary albedo is    : ',globalaverage
call calculateglobalaverage( eg_cst,ev_tsfc,globalaverage )
write(unit=c_standard_message_unit,fmt='(a, f10.2)') ' >> Global mean surface temperature is : ',globalaverage
write(unit=c_standard_message_unit,fmt='(a, i3, a, f10.2)') ' >> Ice boundary in the southern hemisphere: j = ',ev_jice_s,', lat = &
&',ev_yice_s
write(unit=c_standard_message_unit,fmt='(a, i3, a, f10.2)') ' >> Ice boundary in the northern hemisphere: j = ',ev_jice_n,', lat = &
&',ev_yice_n
9000 format(1x,10a)
9100 format(1x,f12.4,20e20.6)
9150 format(1x,f12.4,3f13.1)
9200 format("% Filename: restart.dat"/,"% No. of header lines:  5"/,"% No. of columns:       2"/,"% Column  1: yt         = &
&latitude/degN"/,"% Column  2: tsfc       = surface temperature/degC")
9300 format("% Filename: energy_transport_1d.dat"/,"% No. of header lines:  9"/,"% No. of columns:       6"/,"% Column  1: yu      &
&   = latitude/degN"/,"% Column  2: diff_cnt   = diffusivity/(m s^-2)"/,"% Column  3: heddy      = instantaneous surface &
&meridional energy transport/W"/,"% Column  4: heddy_feb  = NH winter (February) meridional energy transport/W"/,"% Column  5: &
&heddy_aug  = NH summer (August) meridional energy transport/W"/,"% Column  6: heddy_ann  = annual-mean meridional energy &
&transport/W")
9400 format("% Filename: energy_balance_1d.dat"/,"% No. of header lines: 19"/,"% No. of columns:      16"/,"% Column  1: yt        &
& = latitude/degN"/,"% Column  2: solin      = instantaneous solar insolation/(W m^-2)"/,"% Column  3: apln       = instantaneous &
&planetary albedo"/,"% Column  4: netswpln   = instantaneous net shortwave radiation absorbed by planet/(W m^-2)"/,"% Column  5: &
&netlwpln   = instantaneous net longwave radiation emitted by planet/(W m-2)"/,"% Column  6: div_heddy  = instantaneous divergence &
&of meridional energy transport/(W m-2)"/,"% Column  7: tsfc       = instantaneous surface temperature/degC"/,"% Column  8: &
&solin_feb  = NH winter (February) solar insolation/(W m^-2)"/,"% Column  9: solin_aug  = NH summer (August) solar insolation/(W m^&
&-2)"/,"% Column 10: solin_ann  = annual-mean solar insolation/(W m^-2)"/,"% Column 11: apln_feb   = NH winter (February) &
&planetary albedo"/,"% Column 12: apln_aug   = NH summer (August) planetary albedo"/,"% Column 13: apln_ann   = annual-mean &
&planetary albedo"/,"% Column 14: tsfc_feb   = NH winter (February) surface temperature/degC"/,"% Column 15: tsfc_aug   = NH &
&summer (August) surface temperature/degC"/,"% Column 16: tsfc_ann   = annual-mean surface temperature/degC")
9500 format("% Filename: reference.dat"/,"% No. of header lines:  8"/,"% No. of columns:       4"/,"% Column  1: yt       = &
&latitude/degN"/,"% Column  2: tsfc_feb = NH winter (February) surface temperature/degC"/,"% Column  3: tsfc_aug = NH summer &
&(August) surface temperature/degC"/,"% Column  4: tsfc_ann = annual-mean surface temperature/degC")
end subroutine ebm1doutput

subroutine ebm1dreadparameters()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use ebm1dparameters

implicit none

!==============================================
! declare local variables
!==============================================
real :: aice
real :: alw
real :: alwerr
real :: apln0
real :: apln1
real :: apln2
real :: blw
real :: blwerr
real :: co2ccn
real :: co2ref
real :: cp0
real :: diff0
real :: diff0err
real :: diff2
real :: diff2err
real :: diff4
real :: diff4err
real :: dqco2x2
real :: dqco2x2err
integer :: errio
character(len=c_max_len_filename) :: fraccloudfilename
character(len=c_max_len_filename) :: fraclandfilename
character(len=c_max_len_filename) :: gridfilename
real :: hcrat
real :: hocn
real :: hocnerr
character(len=c_max_len_filename) :: parameterfilename
real :: pyear
real :: rhowat
real :: scon0
real :: tcrit
logical :: useicealbedofeedback

!==============================================
! declare namelists
!==============================================
namelist /ebm1d_parameters/ useicealbedofeedback,rhowat,cp0,scon0,pyear,hocn,hcrat,tcrit,alw,blw,dqco2x2,co2ref,co2ccn,apln0,apln1,&
&apln2,aice,diff0,diff2,diff4,gridfilename,fraclandfilename,fraccloudfilename,hocnerr,alwerr,blwerr,dqco2x2err,diff0err,diff2err,&
&diff4err


parameterfilename = 'Ebm1DParametersIn.nml'
write(unit=c_standard_message_unit,fmt=9000) "Ebm1D parameters are read from namelist file '",trim(parameterfilename),"':"
open(unit=c_model_data_unit,file=parameterfilename,status='old',iostat=errio)
read(unit=c_model_data_unit,nml=ebm1d_parameters,iostat=errio)
close(unit=c_model_data_unit)
write(unit=c_standard_message_unit,fmt=*) 'useIceAlbedoFeedback = ',useicealbedofeedback
write(unit=c_standard_message_unit,fmt='(1x, a, a)') 'gridFileName         = ',trim(gridfilename)
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'hocn    = ',hocn
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'tcrit   = ',tcrit
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'apln0   = ',apln0
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'apln1   = ',apln1
write(unit=c_standard_message_unit,fmt='(1x, a, f10.3, a)') 'apln2   = ',apln2
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'aice    = ',aice
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'alw     = ',alw
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'blw     = ',blw
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'diff0   = ',diff0
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'diff2   = ',diff2
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'diff4   = ',diff4
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'dqco2x2 = ',dqco2x2
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'co2ref  = ',co2ref
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'co2ccn  = ',co2ccn
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'hocnerr    = ',hocnerr
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'alwerr     = ',alwerr
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'blwerr     = ',blwerr
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'dqco2x2err = ',dqco2x2err
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'diff0err   = ',diff0err
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'diff2err   = ',diff2err
write(unit=c_standard_message_unit,fmt='(1x, a, f10.2, a)') 'diff4err   = ',diff4err
ep_rhowat = rhowat
ep_cp0 = cp0
ep_scon0 = scon0
ep_pyear = pyear
ep_hocn = hocn
ep_hcrat = hcrat
ep_tcrit = tcrit
ep_alw = alw
ep_blw = blw
ep_dqco2x2 = dqco2x2
ep_co2ref = co2ref
ep_co2ccn = co2ccn
ep_apln0 = apln0
ep_apln1 = apln1
ep_apln2 = apln2
ep_aice = aice
ep_diff0 = diff0
ep_diff2 = diff2
ep_diff4 = diff4
ep_hocnerr = hocnerr
ep_alwerr = alwerr
ep_blwerr = blwerr
ep_dqco2x2err = dqco2x2err
ep_diff0err = diff0err
ep_diff2err = diff2err
ep_diff4err = diff4err
ep_hocnbak = ep_hocn
ep_alwbak = ep_alw
ep_blwbak = ep_blw
ep_dqco2x2bak = dqco2x2
ep_diff0bak = ep_diff0
ep_diff2bak = ep_diff2
ep_diff4bak = ep_diff4
ep_useicealbedofeedback = useicealbedofeedback
ep_gridfilename = gridfilename
ep_fraclandfilename = fraclandfilename
ep_fraccloudfilename = fraccloudfilename
9000 format(1x,10a)
end subroutine ebm1dreadparameters

subroutine ebm1dwritecosts( n, fc_reg, fc_sse, fc )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use ebm1dparameters
use ebm1dgrids
use cost1dvariables

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: fc
real, intent(in) :: fc_reg
real, intent(in) :: fc_sse
integer, intent(in) :: n

!==============================================
! declare local variables
!==============================================
integer :: errio
integer :: j
character(len=c_max_len_filename) :: outputfilename

outputfilename = 'cost_function_terms.dat'
write(unit=c_standard_message_unit,fmt=9000) 'Output (control variables and cost function terms) is written to file "',&
&trim(outputfilename),'".'
open(unit=c_model_data_unit,file=outputfilename,status='REPLACE',iostat=errio)
write(unit=c_model_data_unit,fmt=9200)
if (n .eq. 5) then
  write(unit=c_model_data_unit,fmt='("% ", 5G16.8, 3f10.4)') ep_hocn,ep_alw,ep_diff0,ep_diff2,ep_diff4,fc_reg,fc_sse,fc
else if (n .eq. 6) then
  write(unit=c_model_data_unit,fmt='("% ", 6G16.8, 3f10.4)') ep_hocn,ep_alw,ep_blw,ep_diff0,ep_diff2,ep_diff4,fc_reg,fc_sse,fc
else if (n .eq. 1) then
  write(unit=c_model_data_unit,fmt='("% ",  G16.8, 3f10.4)') ep_dqco2x2,fc_reg,fc_sse,fc
else if (n .eq. 4) then
  write(unit=c_model_data_unit,fmt='("% ", 4G16.8, 3f10.4)') ep_dqco2x2,ep_diff0,ep_diff2,ep_diff4,fc_reg,fc_sse,fc
endif
write(unit=c_model_data_unit,fmt=9300)
do j = 2, jmt-1
  write(unit=c_model_data_unit,fmt=9100) eg_yt(j),cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc),cv_longtermmeanstgrid(j,cp_iaug,&
&cp_itsfc)
end do
close(unit=c_model_data_unit)
9000 format(1x,10a)
9100 format(1x,f12.4,20e20.6)
9200 format("% Filename: cost_function_terms.dat"/,"% No. of header lines: 11"/,"% No. of columns:       3"/,"%"/,"% Values of &
&control variables and cost function:")
9300 format("%"/,"% Column  1: yt       = latitude/degN"/,"% Column  2: tsfc_feb = NH winter (February) surface temperature/degC"/,&
&"% Column  3: tsfc_aug = NH summer (August) surface temperature/degC")
end subroutine ebm1dwritecosts

subroutine ebm1dwriteparameters()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use ebm1dparameters

implicit none

!==============================================
! declare local variables
!==============================================
real :: aice
real :: alw
real :: apln0
real :: apln1
real :: apln2
real :: blw
real :: co2ccn
real :: co2ref
real :: cp0
real :: diff0
real :: diff2
real :: diff4
real :: dqco2x2
integer :: errio
character(len=c_max_len_filename) :: fraccloudfilename
character(len=c_max_len_filename) :: fraclandfilename
character(len=c_max_len_filename) :: gridfilename
real :: hcrat
real :: hocn
character(len=c_max_len_filename) :: parameterfilename
real :: pyear
real :: rhowat
real :: scon0
real :: tcrit
logical :: useicealbedofeedback

!==============================================
! declare namelists
!==============================================
namelist /ebm1d_parameters/ useicealbedofeedback,rhowat,cp0,scon0,pyear,hocn,hcrat,tcrit,alw,blw,dqco2x2,co2ref,co2ccn,apln0,apln1,&
&apln2,aice,diff0,diff2,diff4,gridfilename,fraclandfilename,fraccloudfilename


useicealbedofeedback = ep_useicealbedofeedback
rhowat = ep_rhowat
cp0 = ep_cp0
scon0 = ep_scon0
pyear = ep_pyear
hocn = ep_hocn
hcrat = ep_hcrat
tcrit = ep_tcrit
alw = ep_alw
blw = ep_blw
dqco2x2 = ep_dqco2x2
co2ref = ep_co2ref
co2ccn = ep_co2ccn
apln0 = ep_apln0
apln1 = ep_apln1
apln2 = ep_apln2
aice = ep_aice
diff0 = ep_diff0
diff2 = ep_diff2
diff4 = ep_diff4
gridfilename = ep_gridfilename
fraclandfilename = ep_fraclandfilename
fraccloudfilename = ep_fraccloudfilename
parameterfilename = 'Ebm1DParametersOut.nml'
write(unit=c_standard_message_unit,fmt=9000) "Ebm1D parameters are written to namelist file '",trim(parameterfilename),"'."
open(unit=c_model_data_unit,file=parameterfilename,status='replace',iostat=errio)
write(unit=c_model_data_unit,nml=ebm1d_parameters,iostat=errio)
close(unit=c_model_data_unit)
9000 format(1x,10a)
end subroutine ebm1dwriteparameters

subroutine initializefixed()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters
use ebm1dparameters

implicit none

call readrunparameters
call ebm1dreadparameters
call ebm1dinitializegrids
call ebm1dinitializefixed
call cost1dreadparameters
end subroutine initializefixed

subroutine initializevariables_ad()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use cost1dvariables, only : cv_longtermmeanstgrid_ad
use ebm1dvariables, only : ev_tsfc_ad

implicit none

!----------------------------------------------
! RESET MODULE ADJOINT VARIABLES
!----------------------------------------------
cv_longtermmeanstgrid_ad(:,:,:) = 0.
ev_tsfc_ad(:) = 0.

end subroutine initializevariables_ad

subroutine initializevariables()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

call ebm1dinitializevariables
call cost1dinitializevariables
end subroutine initializevariables

subroutine initmod( n, x )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use optimizationparameters
use ebm1dparameters

implicit none

!==============================================
! declare arguments
!==============================================
integer :: n
real :: x(1:n)

!==============================================
! declare local variables
!==============================================
integer :: i

call initializefixed
call readinitialconditions
call readreferencedata
call readobservations
if (n .eq. 5) then
  cond(1) = ep_diff0
  cond(2) = ep_diff2
  cond(3) = ep_diff4
  cond(4) = ep_alw
  cond(5) = ep_hocn
else if (n .eq. 6) then
  cond(1) = ep_diff0
  cond(2) = ep_diff2
  cond(3) = ep_diff4
  cond(4) = ep_alw
  cond(5) = ep_blw
  cond(6) = ep_hocn
else if (n .eq. 1) then
  cond(1) = ep_dqco2x2
else if (n .eq. 4) then
  cond(1) = ep_diff0
  cond(2) = ep_diff2
  cond(3) = ep_diff4
  cond(4) = ep_dqco2x2
endif
write(unit=c_standard_message_unit,fmt='(1x, a)') '>>> Scaling factors:'
do i = 1, n
  write(unit=c_standard_message_unit,fmt='(1x, a, i2, a, f10.3, a)') 'cond(',i,') = ',cond(i)
end do
if (n .eq. 5) then
  x(1) = ep_diff0/cond(1)
  x(2) = ep_diff2/cond(2)
  x(3) = ep_diff4/cond(3)
  x(4) = ep_alw/cond(4)
  x(5) = ep_hocn/cond(5)
else if (n .eq. 6) then
  x(1) = ep_diff0/cond(1)
  x(2) = ep_diff2/cond(2)
  x(3) = ep_diff4/cond(3)
  x(4) = ep_alw/cond(4)
  x(5) = ep_blw/cond(5)
  x(6) = ep_hocn/cond(6)
else if (n .eq. 1) then
  x(1) = ep_dqco2x2/cond(1)
else if (n .eq. 4) then
  x(1) = ep_diff0/cond(1)
  x(2) = ep_diff2/cond(2)
  x(3) = ep_diff4/cond(3)
  x(4) = ep_dqco2x2/cond(4)
endif
end subroutine initmod

subroutine model_ad( n, x, x_ad, fc, fc_ad )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use optimizationparameters
use sizes
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables
use cost1dparameters
use cost1dvariables
use referencedata
use observations

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(out) :: fc
real, intent(inout) :: fc_ad
integer, intent(in) :: n
real, intent(in) :: x(n)
real, intent(inout) :: x_ad(n)

!==============================================
! declare local variables
!==============================================
real :: fc_reg
real :: fc_reg_ad
real :: fc_regi_ad
real :: fc_sse
real :: fc_sse_ad
integer :: j
integer :: l
real :: sumofweights
logical :: uselongtermmean
logical :: useseasonalmeansonly
real :: value
real :: value_ad
real :: weight
real :: weightedsum
real :: weightedsum_ad

!----------------------------------------------
! RESET GLOBAL ADJOINT VARIABLES
!----------------------------------------------
call zero_ad

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES NO ALLOC
!----------------------------------------------
fc_reg_ad = 0.
fc_sse_ad = 0.
value_ad = 0.
weightedsum_ad = 0.

!----------------------------------------------
! FUNCTION AND TAPE COMPUTATIONS
!----------------------------------------------
if (n .eq. 5) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_alw = x(4)*cond(4)
  ep_hocn = x(5)*cond(5)
else if (n .eq. 6) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_alw = x(4)*cond(4)
  ep_blw = x(5)*cond(5)
  ep_hocn = x(6)*cond(6)
else if (n .eq. 1) then
  ep_dqco2x2 = x(1)*cond(1)
else if (n .eq. 4) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_dqco2x2 = x(4)*cond(4)
endif
ev_ceff = ep_cp0*ep_rhowat*ep_hocn
call initializevariables
if (n .eq. 5) then
  cv_seasonbeg(cp_ifeb) = 31.50
  cv_seasonend(cp_ifeb) = 59.50
  cv_seasonbeg(cp_iaug) = 212.50
  cv_seasonend(cp_iaug) = 243.50
else
  cv_seasonbeg(cp_ifeb) = 31.91
  cv_seasonend(cp_ifeb) = 59.68
  cv_seasonbeg(cp_iaug) = 212.27
  cv_seasonend(cp_iaug) = 243.52
endif
call core
do l = 1, cp_nlongtermperiods
  do j = 2, jmt-1
    cv_longtermmeanstgrid(j,l,cp_isolin) = cv_longtermmeanstgrid(j,l,cp_isolin)/cv_longtermtimes(l)
    cv_longtermmeanstgrid(j,l,cp_iapln) = cv_longtermmeanstgrid(j,l,cp_iapln)/cv_longtermtimes(l)
    cv_longtermmeanstgrid(j,l,cp_itsfc) = cv_longtermmeanstgrid(j,l,cp_itsfc)/cv_longtermtimes(l)
  end do
end do
if (n .eq. 5) then
  fc_reg = 0.5*((ep_hocn-ep_hocnbak)**2/ep_hocnerr**2+(ep_alw-ep_alwbak)**2/ep_alwerr**2+(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+&
&(ep_diff2-ep_diff2bak)**2/ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
else if (n .eq. 6) then
  fc_reg = 0.5*((ep_hocn-ep_hocnbak)**2/ep_hocnerr**2+(ep_alw-ep_alwbak)**2/ep_alwerr**2+(ep_blw-ep_blwbak)**2/ep_blwerr**2+&
&(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+(ep_diff2-ep_diff2bak)**2/ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
else if (n .eq. 1) then
  fc_reg = 0.5*((ep_dqco2x2-ep_dqco2x2bak)**2/ep_dqco2x2err**2)
else if (n .eq. 4) then
  fc_reg = 0.5*((ep_dqco2x2-ep_dqco2x2bak)**2/ep_dqco2x2err**2+(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+(ep_diff2-ep_diff2bak)**2/&
&ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
endif
uselongtermmean =  .true. 
useseasonalmeansonly =  .true. 
sumofweights = 0.0
weightedsum = 0.0
do j = 2, jmt-1
  if (useseasonalmeansonly) then
    if (ob_tsfc(j,cp_ifeb) .eq. ob_tsfc(j,cp_ifeb) .and. ob_tsfc(j,cp_ifeb) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
    if (ob_tsfc(j,cp_iaug) .eq. ob_tsfc(j,cp_iaug) .and. ob_tsfc(j,cp_iaug) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
  else
    if (ob_tsfc(j,cp_iann) .eq. ob_tsfc(j,cp_iann) .and. ob_tsfc(j,cp_iann) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
  endif
end do
fc_sse = 0.5*weightedsum/sumofweights
fc = fc_reg+fc_sse

!----------------------------------------------
! ADJOINT COMPUTATIONS
!----------------------------------------------
fc_reg_ad = fc_reg_ad+fc_ad
fc_sse_ad = fc_sse_ad+fc_ad
fc_ad = 0.
weightedsum_ad = weightedsum_ad+fc_sse_ad*(0.5/sumofweights)
fc_sse_ad = 0.
do j = jmt-1, 2, -1
  if (useseasonalmeansonly) then
    if (ob_tsfc(j,cp_iaug) .eq. ob_tsfc(j,cp_iaug) .and. ob_tsfc(j,cp_iaug) .ne. (-99.99)) then
      weight = eg_cst(j)
      value_ad = value_ad+weightedsum_ad*weight
      if (uselongtermmean) then
        cv_longtermmeanstgrid_ad(j,cp_iaug,cp_itsfc) = cv_longtermmeanstgrid_ad(j,cp_iaug,cp_itsfc)+2*value_ad*&
&(cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))
        value_ad = 0.
      else
        ev_tsfc_ad(j) = ev_tsfc_ad(j)+2*value_ad*(ev_tsfc(j)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))
        value_ad = 0.
      endif
    endif
    if (ob_tsfc(j,cp_ifeb) .eq. ob_tsfc(j,cp_ifeb) .and. ob_tsfc(j,cp_ifeb) .ne. (-99.99)) then
      weight = eg_cst(j)
      value_ad = value_ad+weightedsum_ad*weight
      if (uselongtermmean) then
        cv_longtermmeanstgrid_ad(j,cp_ifeb,cp_itsfc) = cv_longtermmeanstgrid_ad(j,cp_ifeb,cp_itsfc)+2*value_ad*&
&(cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))
        value_ad = 0.
      else
        ev_tsfc_ad(j) = ev_tsfc_ad(j)+2*value_ad*(ev_tsfc(j)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))
        value_ad = 0.
      endif
    endif
  else
    if (ob_tsfc(j,cp_iann) .eq. ob_tsfc(j,cp_iann) .and. ob_tsfc(j,cp_iann) .ne. (-99.99)) then
      weight = eg_cst(j)
      value_ad = value_ad+weightedsum_ad*weight
      if (uselongtermmean) then
        cv_longtermmeanstgrid_ad(j,cp_iann,cp_itsfc) = cv_longtermmeanstgrid_ad(j,cp_iann,cp_itsfc)+2*value_ad*&
&(cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))
        value_ad = 0.
      else
        ev_tsfc_ad(j) = ev_tsfc_ad(j)+2*value_ad*(ev_tsfc(j)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))
        value_ad = 0.
      endif
    endif
  endif
end do
if (n .eq. 5) then
  ep_alw_ad = ep_alw_ad+0.5*fc_reg_ad*(2*(ep_alw-ep_alwbak)/ep_alwerr**2)
  ep_diff0_ad = ep_diff0_ad+0.5*fc_reg_ad*(2*(ep_diff0-ep_diff0bak)/ep_diff0err**2)
  ep_diff2_ad = ep_diff2_ad+0.5*fc_reg_ad*(2*(ep_diff2-ep_diff2bak)/ep_diff2err**2)
  ep_diff4_ad = ep_diff4_ad+0.5*fc_reg_ad*(2*(ep_diff4-ep_diff4bak)/ep_diff4err**2)
  ep_hocn_ad = ep_hocn_ad+0.5*fc_reg_ad*(2*(ep_hocn-ep_hocnbak)/ep_hocnerr**2)
  fc_reg_ad = 0.
else if (n .eq. 6) then
  fc_regi_ad = 0.5*fc_reg_ad
  ep_alw_ad = ep_alw_ad+fc_regi_ad*(2*(ep_alw-ep_alwbak)/ep_alwerr**2)
  ep_blw_ad = ep_blw_ad+fc_regi_ad*(2*(ep_blw-ep_blwbak)/ep_blwerr**2)
  ep_diff0_ad = ep_diff0_ad+fc_regi_ad*(2*(ep_diff0-ep_diff0bak)/ep_diff0err**2)
  ep_diff2_ad = ep_diff2_ad+fc_regi_ad*(2*(ep_diff2-ep_diff2bak)/ep_diff2err**2)
  ep_diff4_ad = ep_diff4_ad+fc_regi_ad*(2*(ep_diff4-ep_diff4bak)/ep_diff4err**2)
  ep_hocn_ad = ep_hocn_ad+fc_regi_ad*(2*(ep_hocn-ep_hocnbak)/ep_hocnerr**2)
  fc_reg_ad = 0.
else if (n .eq. 1) then
  ep_dqco2x2_ad = ep_dqco2x2_ad+0.5*fc_reg_ad*(2*(ep_dqco2x2-ep_dqco2x2bak)/ep_dqco2x2err**2)
  fc_reg_ad = 0.
else if (n .eq. 4) then
  ep_diff0_ad = ep_diff0_ad+0.5*fc_reg_ad*(2*(ep_diff0-ep_diff0bak)/ep_diff0err**2)
  ep_diff2_ad = ep_diff2_ad+0.5*fc_reg_ad*(2*(ep_diff2-ep_diff2bak)/ep_diff2err**2)
  ep_diff4_ad = ep_diff4_ad+0.5*fc_reg_ad*(2*(ep_diff4-ep_diff4bak)/ep_diff4err**2)
  ep_dqco2x2_ad = ep_dqco2x2_ad+0.5*fc_reg_ad*(2*(ep_dqco2x2-ep_dqco2x2bak)/ep_dqco2x2err**2)
  fc_reg_ad = 0.
endif
do l = 1, cp_nlongtermperiods
  do j = 2, jmt-1
    cv_longtermmeanstgrid_ad(j,l,cp_itsfc) = cv_longtermmeanstgrid_ad(j,l,cp_itsfc)/cv_longtermtimes(l)
    cv_longtermmeanstgrid_ad(j,l,cp_iapln) = cv_longtermmeanstgrid_ad(j,l,cp_iapln)/cv_longtermtimes(l)
    cv_longtermmeanstgrid_ad(j,l,cp_isolin) = cv_longtermmeanstgrid_ad(j,l,cp_isolin)/cv_longtermtimes(l)
  end do
end do
call initializevariables
call core_ad
call initializevariables_ad
ep_hocn_ad = ep_hocn_ad+ev_ceff_ad*ep_cp0*ep_rhowat
ev_ceff_ad = 0.
if (n .eq. 5) then
  x_ad(5) = x_ad(5)+ep_hocn_ad*cond(5)
  ep_hocn_ad = 0.
  x_ad(4) = x_ad(4)+ep_alw_ad*cond(4)
  ep_alw_ad = 0.
  x_ad(3) = x_ad(3)+ep_diff4_ad*cond(3)
  ep_diff4_ad = 0.
  x_ad(2) = x_ad(2)+ep_diff2_ad*cond(2)
  ep_diff2_ad = 0.
  x_ad(1) = x_ad(1)+ep_diff0_ad*cond(1)
  ep_diff0_ad = 0.
else if (n .eq. 6) then
  x_ad(6) = x_ad(6)+ep_hocn_ad*cond(6)
  ep_hocn_ad = 0.
  x_ad(5) = x_ad(5)+ep_blw_ad*cond(5)
  ep_blw_ad = 0.
  x_ad(4) = x_ad(4)+ep_alw_ad*cond(4)
  ep_alw_ad = 0.
  x_ad(3) = x_ad(3)+ep_diff4_ad*cond(3)
  ep_diff4_ad = 0.
  x_ad(2) = x_ad(2)+ep_diff2_ad*cond(2)
  ep_diff2_ad = 0.
  x_ad(1) = x_ad(1)+ep_diff0_ad*cond(1)
  ep_diff0_ad = 0.
else if (n .eq. 1) then
  x_ad(1) = x_ad(1)+ep_dqco2x2_ad*cond(1)
  ep_dqco2x2_ad = 0.
else if (n .eq. 4) then
  x_ad(4) = x_ad(4)+ep_dqco2x2_ad*cond(4)
  ep_dqco2x2_ad = 0.
  x_ad(3) = x_ad(3)+ep_diff4_ad*cond(3)
  ep_diff4_ad = 0.
  x_ad(2) = x_ad(2)+ep_diff2_ad*cond(2)
  ep_diff2_ad = 0.
  x_ad(1) = x_ad(1)+ep_diff0_ad*cond(1)
  ep_diff0_ad = 0.
endif

end subroutine model_ad

subroutine model( n, x, fc )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use optimizationparameters
use sizes
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables
use cost1dparameters
use cost1dvariables
use referencedata
use observations

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: fc
integer, intent(in) :: n
real, intent(in) :: x(n)

!==============================================
! declare local variables
!==============================================
real :: fc_reg
real :: fc_sse
integer :: i
integer :: j
integer :: l
real :: sumofweights
logical :: uselongtermmean
logical :: useseasonalmeansonly
real :: value
real :: weight
real :: weightedsum

if (n .eq. 5) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_alw = x(4)*cond(4)
  ep_hocn = x(5)*cond(5)
else if (n .eq. 6) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_alw = x(4)*cond(4)
  ep_blw = x(5)*cond(5)
  ep_hocn = x(6)*cond(6)
else if (n .eq. 1) then
  ep_dqco2x2 = x(1)*cond(1)
else if (n .eq. 4) then
  ep_diff0 = x(1)*cond(1)
  ep_diff2 = x(2)*cond(2)
  ep_diff4 = x(3)*cond(3)
  ep_dqco2x2 = x(4)*cond(4)
endif
print '(1x, a)', '>>> Control variables:'
do i = 1, n
  print '(1x, a, i2, a, i2, a, e14.8)', ' i = ',i,', x(',i,') = ',x(i)
end do
print *, ' ep_useIceAlbedoFeedback = ',ep_useicealbedofeedback
ev_ceff = ep_cp0*ep_rhowat*ep_hocn
call initializevariables
fc = 0.0
if (n .eq. 5) then
  cv_seasonbeg(cp_ifeb) = 31.50
  cv_seasonend(cp_ifeb) = 59.50
  cv_seasonbeg(cp_iaug) = 212.50
  cv_seasonend(cp_iaug) = 243.50
else
  cv_seasonbeg(cp_ifeb) = 31.91
  cv_seasonend(cp_ifeb) = 59.68
  cv_seasonbeg(cp_iaug) = 212.27
  cv_seasonend(cp_iaug) = 243.52
endif
print *, '**************************************'
print *, '***     RUNNING EBM1D               **'
print *, '**************************************'
call core
do l = 1, cp_nlongtermperiods
  cv_longtermmeans(l,cp_iyice_s) = cv_longtermmeans(l,cp_iyice_s)/cv_longtermtimes(l)
  cv_longtermmeans(l,cp_iyice_n) = cv_longtermmeans(l,cp_iyice_n)/cv_longtermtimes(l)
  do j = 2, jmt-1
    cv_longtermmeanstgrid(j,l,cp_isolin) = cv_longtermmeanstgrid(j,l,cp_isolin)/cv_longtermtimes(l)
    cv_longtermmeanstgrid(j,l,cp_iapln) = cv_longtermmeanstgrid(j,l,cp_iapln)/cv_longtermtimes(l)
    cv_longtermmeanstgrid(j,l,cp_itsfc) = cv_longtermmeanstgrid(j,l,cp_itsfc)/cv_longtermtimes(l)
  end do
  do j = 2, jmt-2
    cv_longtermmeansugrid(j,l,cp_iheddy) = cv_longtermmeansugrid(j,l,cp_iheddy)/cv_longtermtimes(l)
  end do
end do
call ebm1doutput
if (n .eq. 5) then
  fc_reg = 0.5*((ep_hocn-ep_hocnbak)**2/ep_hocnerr**2+(ep_alw-ep_alwbak)**2/ep_alwerr**2+(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+&
&(ep_diff2-ep_diff2bak)**2/ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
else if (n .eq. 6) then
  fc_reg = 0.5*((ep_hocn-ep_hocnbak)**2/ep_hocnerr**2+(ep_alw-ep_alwbak)**2/ep_alwerr**2+(ep_blw-ep_blwbak)**2/ep_blwerr**2+&
&(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+(ep_diff2-ep_diff2bak)**2/ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
else if (n .eq. 1) then
  fc_reg = 0.5*((ep_dqco2x2-ep_dqco2x2bak)**2/ep_dqco2x2err**2)
else if (n .eq. 4) then
  fc_reg = 0.5*((ep_dqco2x2-ep_dqco2x2bak)**2/ep_dqco2x2err**2+(ep_diff0-ep_diff0bak)**2/ep_diff0err**2+(ep_diff2-ep_diff2bak)**2/&
&ep_diff2err**2+(ep_diff4-ep_diff4bak)**2/ep_diff4err**2)
endif
uselongtermmean =  .true. 
useseasonalmeansonly =  .true. 
sumofweights = 0.0
weightedsum = 0.0
print *, 'useLongTermMean      = ',uselongtermmean
print *, 'useSeasonalMeansOnly = ',useseasonalmeansonly
print *, 'cv_longTermTimes(',cp_ifeb,') = ',cv_longtermtimes(cp_ifeb)
print *, 'cv_longTermTimes(',cp_iaug,') = ',cv_longtermtimes(cp_iaug)
print *, 'cv_longTermTimes(',cp_iann,') = ',cv_longtermtimes(cp_iann)
do j = 2, jmt-1
  if (useseasonalmeansonly) then
    if (ob_tsfc(j,cp_ifeb) .eq. ob_tsfc(j,cp_ifeb) .and. ob_tsfc(j,cp_ifeb) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_ifeb,cp_itsfc)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_ifeb)-ob_tsfc(j,cp_ifeb))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
    if (ob_tsfc(j,cp_iaug) .eq. ob_tsfc(j,cp_iaug) .and. ob_tsfc(j,cp_iaug) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_iaug,cp_itsfc)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_iaug)-ob_tsfc(j,cp_iaug))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
  else
    if (ob_tsfc(j,cp_iann) .eq. ob_tsfc(j,cp_iann) .and. ob_tsfc(j,cp_iann) .ne. (-99.99)) then
      weight = eg_cst(j)
      if (uselongtermmean) then
        value = (cv_longtermmeanstgrid(j,cp_iann,cp_itsfc)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))**2
      else
        value = (ev_tsfc(j)-rf_tsfc(j,cp_iann)-ob_tsfc(j,cp_iann))**2
      endif
      sumofweights = sumofweights+weight
      weightedsum = weightedsum+weight*value
    endif
  endif
end do
fc_sse = 0.5*weightedsum/sumofweights
fc = fc_reg+fc_sse
call ebm1dwritecosts( n,fc_reg,fc_sse,fc )
end subroutine model

subroutine numbmod( n )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
implicit none

!==============================================
! declare arguments
!==============================================
integer :: n

n = 5
end subroutine numbmod

subroutine orbcomputeelements( t2, ecc, perh, xob, pre )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use orbparameters

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(out) :: ecc
real, intent(out) :: perh
real, intent(out) :: pre
real, intent(in) :: t2
real, intent(out) :: xob

!==============================================
! declare local variables
!==============================================
real :: arg
integer :: i
integer :: j
real :: prg
real :: rp
real :: xec
real :: xes

xes = 0.0
xec = 0.0
do j = 1, neff
  arg = be(j)*t2+ce(j)
  xes = xes+ae(j)*sin(arg)
  xec = xec+ae(j)*cos(arg)
end do
ecc = sqrt(xes**2+xec**2)
if (abs(xec) .gt. 1.0e-08) then
  rp = atan(xes/xec)
  if (xec .lt. 0.0) then
    rp = rp+c_pi
  else if (xes .lt. 0.0) then
    rp = rp+2.0*c_pi
  endif
else
  if (xes .lt. 0.0) then
    rp = 1.5*c_pi
  else if (xes .gt. 0.0) then
    rp = 0.5*c_pi
  else
    rp = 0.0
  endif
endif
perh = rp*c_rad2deg
prg = prm*t2
do i = 1, nopp
  arg = bop(i)*t2+cop(i)
  prg = prg+aop(i)*sin(arg)
end do
prg = prg/3600.0+xop
perh = perh+prg
if (perh .lt. 0.0) then
  do
    perh = perh+360.0
    if (perh .gt. 0.0) then
      exit
    endif
  end do
else
  if (perh .gt. 360.0) then
    do
      perh = perh-360.0
      if (perh .lt. 360.0) then
        exit
      endif
    end do
  endif
endif
pre = ecc*sin(perh*c_deg2rad)
xob = xod
do i = 1, nobb
  arg = bob(i)*t2+cob(i)
  xob = xob+aob(i)/3600.0*cos(arg)
end do
end subroutine orbcomputeelements

subroutine orbdaily( scon, eccen, obliq, perihp, lambdap, phi, wdaily, cosz )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use orbparameters

implicit none

!==============================================
! declare arguments
!==============================================
real, intent(out) :: cosz
real, intent(in) :: eccen
real, intent(in) :: lambdap
real, intent(in) :: obliq
real, intent(in) :: perihp
real, intent(in) :: phi
real, intent(in) :: scon
real, intent(out) :: wdaily

!==============================================
! declare local variables
!==============================================
real :: delta
real :: hour0
real :: lambdap1
real :: nu
real :: obliq1
real :: perihp1
real :: phi1
real :: rho
real :: winteg

perihp1 = perihp*c_deg2rad
obliq1 = obliq*c_deg2rad
lambdap1 = lambdap*c_deg2rad
phi1 = phi*c_deg2rad
delta = -asin(sin(obliq1)*cos(lambdap1))
if (abs(phi1) .ge. c_pi/2.0-abs(delta) .and. phi1*delta .lt. 0.0) then
  wdaily = 0.0
  cosz = 0.0
else
  nu = lambdap1-perihp1
  rho = (1.0-eccen**2)/(1.0+eccen*cos(nu))
  if (abs(phi1) .ge. c_pi/2.0-abs(delta) .and. phi1*delta .gt. 0.0) then
    winteg = sin(phi1)*sin(delta)
    wdaily = scon/rho**2*winteg
    cosz = (sin(phi1)**2*sin(delta)**2+0.5*cos(phi1)**2*cos(delta)**2)/winteg
  else
    hour0 = acos(-(tan(phi1)*tan(delta)))
    winteg = hour0*sin(phi1)*sin(delta)+cos(phi1)*cos(delta)*sin(hour0)
    wdaily = scon/(c_pi*rho**2)*winteg
    cosz = (hour0*(sin(phi1)**2*sin(delta)**2+0.5*cos(phi1)**2*cos(delta)**2)+2.0*sin(phi1)*sin(delta)*cos(phi1)*cos(delta)*&
&sin(hour0)+0.25*cos(phi1)**2*cos(delta)**2*sin(2.0*hour0))/winteg
  endif
endif
end subroutine orbdaily

subroutine orbinitializeelements()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use orbparameters

implicit none

!==============================================
! declare local variables
!==============================================
character(len=c_max_len_filename) :: eccentricitydatafilename
integer :: errio
integer :: i
integer :: j
character(len=80) :: record

eccentricitydatafilename = '../input/eccentricity.dat'
write(unit=c_standard_message_unit,fmt=9000) "Eccentricity data are read from file '",trim(eccentricitydatafilename),"'"
open(unit=c_model_data_unit,file=eccentricitydatafilename,status='old',iostat=errio)
j = 0
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) ae(j),be(j),ce(j)
  endif
end do
close(unit=c_model_data_unit)
eccentricitydatafilename = '../input/obliquity.dat'
write(unit=c_standard_message_unit,fmt=9000) "Obliquity data are read from file '",trim(eccentricitydatafilename),"'"
open(unit=c_model_data_unit,file=eccentricitydatafilename,status='old',iostat=errio)
j = 0
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) aob(j),bob(j),cob(j)
  endif
end do
close(unit=c_model_data_unit)
eccentricitydatafilename = '../input/precession.dat'
write(unit=c_standard_message_unit,fmt=9000) "Precession data are read from file '",trim(eccentricitydatafilename),"'"
open(unit=c_model_data_unit,file=eccentricitydatafilename,status='old',iostat=errio)
j = 0
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) aop(j),bop(j),cop(j)
  endif
end do
close(unit=c_model_data_unit)
do i = 1, nef
  be(i) = be(i)*c_sec2rad
  ce(i) = ce(i)*c_deg2rad
end do
do i = 1, nob
  bob(i) = bob(i)*c_sec2rad
  cob(i) = cob(i)*c_deg2rad
end do
do i = 1, nop
  bop(i) = bop(i)*c_sec2rad
  cop(i) = cop(i)*c_deg2rad
end do
9000 format(1x,10a)
end subroutine orbinitializeelements

function   orbtime2longitude( ecc, omegap, cday )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use orbparameters

implicit none

!==============================================
! declare parameters
!==============================================
real, parameter :: step = 360.0/365.0

!==============================================
! declare arguments
!==============================================
real, intent(in) :: cday
real, intent(in) :: ecc
real, intent(in) :: omegap
real :: orbtime2longitude

!==============================================
! declare local variables
!==============================================
real :: beta
real :: ecc2
real :: ecc3
real :: lambda
real :: lambda_m
real :: lambda_m0
real :: nu_m
real :: omega
real :: omegap1

ecc2 = ecc*ecc
ecc3 = ecc2*ecc
beta = sqrt(1.0-ecc2)
omegap1 = omegap*c_deg2rad
omega = omegap1+3.0*c_pi/2.0
lambda_m0 = (ecc/2.0+ecc3/8.0)*(1.0+beta)*sin(omega)-ecc2/4.0*(0.5+beta)*sin(2.0*omega)+ecc*ecc2/8.0*(1.0/3.0+beta)*sin(3.0*omega)
lambda_m0 = 2.0*lambda_m0
lambda_m = lambda_m0+(cday-80.0)*step*c_deg2rad
nu_m = lambda_m-omega
lambda = lambda_m+(2.0*ecc-ecc3/4.0)*sin(nu_m)+5.0/4.0*ecc2*sin(2.0*nu_m)+13.0/12.0*ecc3*sin(3.0*nu_m)
lambda = lambda+c_pi/2.0
if (lambda .gt. 2.0*c_pi) then
  orbtime2longitude = (lambda-2.0*c_pi)*c_rad2deg
else if (lambda .lt. 0.0) then
  orbtime2longitude = (lambda+2.0*c_pi)*c_rad2deg
else
  orbtime2longitude = lambda*c_rad2deg
endif
end function   orbtime2longitude

subroutine readinitialconditions()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use cost1dparameters
use runparameters
use initialconditions

implicit none

!==============================================
! declare local variables
!==============================================
integer :: errio
integer :: i
integer :: itimeperiods
integer :: j
character(len=80) :: record
real :: tic(1:jmt,1:cp_nlongtermperiods)
real :: yic(1:jmt)

write(unit=c_standard_message_unit,fmt=9000) "Initial conditions are read from file '",trim(rp_initialconditionsfilename),"'"
open(unit=c_model_data_unit,file=rp_initialconditionsfilename,status='old',iostat=errio)
j = 1
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) yic(j),(tic(j,itimeperiods),itimeperiods=1,cp_nlongtermperiods)
  endif
end do
close(unit=c_model_data_unit)
ic_tsfc = tic(1:jmt,cp_iann)
9000 format(1x,10a)
end subroutine readinitialconditions

subroutine readobservations()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use cost1dparameters
use runparameters
use observations

implicit none

!==============================================
! declare local variables
!==============================================
integer :: errio
integer :: i
integer :: itimeperiods
integer :: j
character(len=80) :: record
real :: tobs(1:jmt,1:cp_nlongtermperiods)
real :: yobs(1:jmt)

write(unit=c_standard_message_unit,fmt=9000) "Observations are read from file '",trim(rp_observationsfilename),"'"
open(unit=c_model_data_unit,file=rp_observationsfilename,status='old',iostat=errio)
if (errio .ne. 0) then
  write(unit=c_standard_message_unit,fmt=9000) "Error in reading observations from file '",trim(rp_observationsfilename),"'"
  stop
endif
j = 1
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) yobs(j),(tobs(j,itimeperiods),itimeperiods=1,cp_nlongtermperiods)
  endif
end do
close(unit=c_model_data_unit)
ob_tsfc = tobs
9000 format(1x,10a)
end subroutine readobservations

subroutine readreferencedata()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use sizes
use constants
use cost1dparameters
use runparameters
use referencedata

implicit none

!==============================================
! declare local variables
!==============================================
integer :: errio
integer :: i
integer :: itimeperiods
integer :: j
character(len=80) :: record
real :: tref(1:jmt,1:cp_nlongtermperiods)
real :: yref(1:jmt)

write(unit=c_standard_message_unit,fmt=9000) "Reference data are read from file '",trim(rp_referencedatafilename),"'"
open(unit=c_model_data_unit,file=rp_referencedatafilename,status='old',iostat=errio)
j = 1
do i = 1, 100
  read(unit=c_model_data_unit,fmt='(a)',iostat=errio) record
  if (errio .eq. 0 .and. record(1:1) .ne. '%') then
    j = j+1
    read(unit=record,fmt=*) yref(j),(tref(j,itimeperiods),itimeperiods=1,cp_nlongtermperiods)
  endif
end do
close(unit=c_model_data_unit)
rf_tsfc = tref
9000 format(1x,10a)
end subroutine readreferencedata

subroutine readrunparameters()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use constants
use runparameters

implicit none

!==============================================
! declare local variables
!==============================================
real :: deltat
real :: endtime
integer :: errio
character(len=c_max_len_filename) :: initialconditionsfilename
character(len=c_max_len_filename) :: observationsfilename
character(len=c_max_len_filename) :: parameterfilename
character(len=c_max_len_filename) :: referencedatafilename
character(len=c_max_len_filename) :: restartdatafilename
real :: starttime

!==============================================
! declare namelists
!==============================================
namelist /run_parameters/ starttime,endtime,deltat,initialconditionsfilename,restartdatafilename,referencedatafilename,&
&observationsfilename


parameterfilename = 'RunParameters.nml'
write(unit=c_standard_message_unit,fmt=9000) "Run parameters are read from namelist file '",trim(parameterfilename),"':"
open(unit=c_model_data_unit,file=parameterfilename,status='old',iostat=errio)
read(unit=c_model_data_unit,nml=run_parameters,iostat=errio)
close(unit=c_model_data_unit)
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'startTime = ',starttime,' a'
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'endTime   = ',endtime,' a'
write(unit=c_standard_message_unit,fmt='(1x, a, f10.1, a)') 'deltaT    = ',deltat,' s'
write(unit=c_standard_message_unit,fmt='(1x, a, a, a)') "initialConditionsFileName = '",trim(initialconditionsfilename),"'"
write(unit=c_standard_message_unit,fmt='(1x, a ,a, a)') "restartDataFileName       = '",trim(restartdatafilename),"'"
write(unit=c_standard_message_unit,fmt='(1x, a, a, a)') "referenceDataFileName     = '",trim(referencedatafilename),"'"
write(unit=c_standard_message_unit,fmt='(1x, a, a ,a)') "observationsFileName      = '",trim(observationsfilename),"'"
rp_starttime = starttime*c_days_per_year*c_seconds_per_day
rp_endtime = endtime*c_days_per_year*c_seconds_per_day
rp_deltat = deltat
rp_ntimesteps = (rp_endtime-rp_starttime)/rp_deltat
write(unit=c_standard_message_unit,fmt='(1x, a, f20.1, a)') 'startTime  = ',rp_starttime,' s'
write(unit=c_standard_message_unit,fmt='(1x, a, f20.1, a)') 'endTime    = ',rp_endtime,' s'
write(unit=c_standard_message_unit,fmt='(1x, a, I20)') 'nTimeSteps = ',rp_ntimesteps
rp_initialconditionsfilename = initialconditionsfilename
rp_restartdatafilename = restartdatafilename
rp_referencedatafilename = referencedatafilename
rp_observationsfilename = observationsfilename
9000 format(1x,10a)
end subroutine readrunparameters

subroutine zero_ad()
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 4.0.3   **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use optimizationparameters
use sizes
use ebm1dgrids
use ebm1dparameters
use ebm1dvariables
use cost1dparameters
use cost1dvariables
use referencedata
use observations

implicit none


!----------------------------------------------
! reset adjoint module variables
!----------------------------------------------
call cost1dvariables_constructor_ad
call ebm1dparameters_constructor_ad
call ebm1dvariables_constructor_ad

end subroutine zero_ad
